{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documenta\u00e7\u00e3o das Tarefas","text":""},{"location":"#tarefa-1-variavel-de-ambiente","title":"Tarefa 1: Vari\u00e1vel de Ambiente","text":"<p>Modificar a aplica\u00e7\u00e3o para consumir uma vari\u00e1vel de ambiente chamada <code>NAME</code> e, no lugar de \"World\", exibir o valor dessa vari\u00e1vel.</p> <p>Para a aplica\u00e7\u00e3o consumir a vari\u00e1vel de ambiente <code>NAME</code>, basta usar o m\u00f3dulo <code>os</code> nativo do Python. O m\u00e9todo <code>os.environ.get()</code> recebe duas strings de argumento. A primeira refere-se ao nome da vari\u00e1vel de ambiente. Se ela existir, ent\u00e3o a fun\u00e7\u00e3o retorna seu valor, sen\u00e3o, retorna o segundo argumento passado.</p> <pre><code>@app.route(\"/\")\ndef hello_world():\nname = os.environ.get(\"NAME\", \"World\")\nreturn f\"Hello, {name}!\"\n</code></pre>"},{"location":"#tarefa-2-gitignore","title":"Tarefa 2: .gitignore","text":"<p>Modificar o arquivo <code>.gitignore</code> para que seja adequado a uma aplica\u00e7\u00e3o Python.</p> <p>No arquivo <code>.gitignore</code>, faz-se refer\u00eancia a arquivos/diret\u00f3rios com as seguintes caracter\u00edsticas:</p> <ul> <li>Arquivos otimizados / bin\u00e1rios</li> <li>Ambientes virtuais Python (<code>venv</code>)</li> <li>Arquivos espec\u00edficos do IDE</li> <li>Arquivos de Log</li> </ul> <p>entre outros.</p>"},{"location":"#tarefa-3-fluxo-de-desenvolvimento","title":"Tarefa 3: Fluxo de Desenvolvimento","text":"<p>Elaborar, implementar e refor\u00e7ar o fluxo de desenvolvimento do reposit\u00f3rio.</p> <p>Sugest\u00e3o de fluxo de desenvolvimento com o seguinte padr\u00e3o de cria\u00e7\u00e3o/merge de branches:</p> <ul> <li> <p>Branches Principais:</p> <ul> <li><code>master</code>: Representa a vers\u00e3o est\u00e1vel e pronta para produ\u00e7\u00e3o da aplica\u00e7\u00e3o.</li> <li><code>develop</code>: Serve como branch de integra\u00e7\u00e3o para o desenvolvimento cont\u00ednuo.</li> </ul> </li> <li> <p>Branches de Funcionalidades:</p> <ul> <li>Para cada nova funcionalidade ou tarefa, crie uma nova branch a partir da <code>develop</code>.</li> <li>D\u00ea um nome descritivo \u00e0 branch de funcionalidade, como <code>feature/user-authentication</code>.</li> </ul> </li> <li> <p>Hotfix:</p> <ul> <li>Se houver um bug cr\u00edtico na vers\u00e3o de produ\u00e7\u00e3o, crie uma branch de Hotfix a partir da <code>master</code>.</li> <li>D\u00ea um nome descritivo \u00e0 branch de Hotfix, como <code>hotfix/fix-login-issue</code>.</li> </ul> </li> <li> <p>Branches de Lan\u00e7amento (Release):</p> <ul> <li>Quando a branch <code>develop</code> atingir um ponto est\u00e1vel para um lan\u00e7amento, crie uma branch de release a partir dela.</li> <li>D\u00ea um nome da branch com base no n\u00famero da vers\u00e3o, como <code>release/1.0</code>.</li> </ul> </li> <li> <p>Merging:</p> <ul> <li>Fa\u00e7a merge nas branches de funcionalidades de volta \u00e0 <code>develop</code> assim que as funcionalidades estiverem conclu\u00eddas e testadas.</li> <li>Fa\u00e7a merge nas branches de release tanto na <code>develop</code> quanto na <code>master</code> ap\u00f3s testar e garantir a estabilidade.</li> <li>Fa\u00e7a merge nas branches de Hotfix tanto no <code>develop</code> quanto no <code>master</code> para aplicar corre\u00e7\u00f5es cr\u00edticas \u00e0 vers\u00e3o de produ\u00e7\u00e3o.</li> <li>Sempre usar Pull Requests para as branches principais (branches protegidas).</li> </ul> </li> <li> <p>Tagging:</p> <ul> <li>Sempre que dar merge numa branch de release na <code>master</code>, crie uma tag para a vers\u00e3o espec\u00edfica. Isso facilita o rastreamento dos lan\u00e7amentos.</li> </ul> </li> </ul> <p>Mensagens de commits devem deve ser estruturada seguindo o padr\u00e3o Conventional Commits <code>v1.0.0</code>:</p> <p>A especifica\u00e7\u00e3o Conventional Commits fornece um conjunto simples de regras para criar um hist\u00f3rico de commits expl\u00edcito, o que facilita a escrita de ferramentas automatizadas por cima dele. Essa conven\u00e7\u00e3o se alinha com o SemVer, descrevendo as funcionalidades, corre\u00e7\u00f5es e mudan\u00e7as que quebram compatibilidade presentes nas mensagens de commit.</p> <pre><code>&lt;tipo&gt;[escopo opcional]: &lt;descri\u00e7\u00e3o&gt;\n\n[corpo opcional]\n\n[rodap\u00e9(s) opcional(is)]\n</code></pre>"},{"location":"#tarefa-4-boas-praticas-no-repositorio","title":"Tarefa 4: Boas Pr\u00e1ticas no Reposit\u00f3rio","text":"<p>Consolidar boas pr\u00e1ticas no reposit\u00f3rio atrav\u00e9s de ferramentas de an\u00e1lise est\u00e1tica, hooks de pr\u00e9-commit, etc. a seu crit\u00e9rio.</p> <p>Foram usadas as seguintes ferramentas com o intuito de consolidar boas pr\u00e1ticas no reposit\u00f3rio:</p> <ul> <li>Poetry: ferramenta de gerenciamento de depend\u00eancias e empacotamento de projetos Python. Com <code>poetry.lock</code> garante um snapshot das dependencias podendo ser facilmente replicado em outras inst\u00e2ncias.</li> <li>Semgrep:  ferramenta de an\u00e1lise est\u00e1tica de c\u00f3digo que permite encontrar e corrigir problemas de seguran\u00e7a, bugs e m\u00e1s pr\u00e1ticas em seus projetos de c\u00f3digo-fonte. Ele usa regras de an\u00e1lise baseadas em padr\u00f5es e express\u00f5es regulares para identificar poss\u00edveis vulnerabilidades e problemas no c\u00f3digo.</li> <li>Black: garante que o c\u00f3digo siga um estilo de formata\u00e7\u00e3o consistente e padronizado, tornando-o mais leg\u00edvel e mantendo uma apar\u00eancia uniforme em projetos compartilhados por v\u00e1rias pessoas.</li> <li>Isort: ferramenta de ordena\u00e7\u00e3o de importa\u00e7\u00f5es em c\u00f3digo fonte Python. Ele reorganiza as declara\u00e7\u00f5es de importa\u00e7\u00e3o em ordem alfab\u00e9tica e agrupa-as de forma coerente, tornando o c\u00f3digo mais organizado.</li> <li>Flake8: combina v\u00e1rias ferramentas populares, como o PyFlakes (verificador de erros est\u00e1ticos) e o pycodestyle (verificador de conformidade de estilo PEP 8), al\u00e9m de verificar a complexidade do c\u00f3digo com o mccabe. O Flake8 ajuda a identificar problemas potenciais no c\u00f3digo, como erros de sintaxe, problemas de estilo e complexidade excessiva.</li> <li>MKDocs: ferramenta de cria\u00e7\u00e3o de documenta\u00e7\u00e3o est\u00e1tica em Markdown. Ele possui v\u00e1rias facilidades como o comando <code>mkdocs serve</code> que inicia um servidor local em que voc\u00ea pode visualizar a documenta\u00e7\u00e3o no navegador em tempo real enquanto faz altera\u00e7\u00f5es no conte\u00fado ou no estilo. Al\u00e9m do comando <code>mkdocs gh-deploy</code>, que compila a documenta\u00e7\u00e3o e a implanta na branch \"gh-pages\" do reposit\u00f3rio do GitHub, tornando-a publicamente acess\u00edvel em um URL espec\u00edfico do GitHub Pages.</li> <li>PyTest: oferece recursos poderosos, como detec\u00e7\u00e3o autom\u00e1tica de testes e testes parametrizados. Com PyTest-cov foi poss\u00edvel intreg\u00e1-lo com a ferramente descrita a seguir.</li> <li>Coverage: com essa ferramenta \u00e9 poss\u00edvel medir a cobertura de c\u00f3digo do projeto, ou seja, quantas linhas de c\u00f3digo foram executadas durante a execu\u00e7\u00e3o dos testes. Com o comando <code>coverage html</code> ele gera uma aplica\u00e7\u00e3o web local (hospedada por padr\u00e3o na porta <code>8000</code>) contendo relat\u00f3rios detalhados que mostram quais partes do c\u00f3digo n\u00e3o foram cobertas pelos testes.</li> <li> <p>TaskiPy: diminui o quanto digitamos para usar as ferramentas que foram descritas at\u00e9 ent\u00e3o. A ideia \u00e9 definir as tarefas numa sess\u00e3o do <code>pyproject.toml</code>, e estas s\u00e3o executadas com um comando simples (<code>task &lt;nome do comando&gt;</code>).</p> <pre><code>[tool.taskipy.tasks]\n...\nlint = \"semgrep scan --verbose --config auto &amp;&amp; black . &amp;&amp; isort . &amp;&amp; flake8 .\"\ndocs = \"mkdocs serve\"\ndocs_deploy = \"mkdocs gh-deploy\"\ntest = \"pytest -s -x --cov=src\"\ncov = \"coverage html\"\n</code></pre> </li> <li> <p>pre-commit: permite configurar pre-commit hooks que s\u00e3o executados antes de um commit ser realizado. Neste caso, foi incluido a <code>task test</code> definido com o Taskipy al\u00e9m da checagem est\u00e1tica com o semgrep, black, isort e flake8, al\u00e9m de verificar marcador de ordem de byte UTF-8, corrigir pragma de codifica\u00e7\u00e3o do Python, remover espa\u00e7os em branco no final de cada linha, n\u00e3o permitir fazer commit em branches protegidas e verificar se arquivos grandes foram adicionados.</p> </li> <li> <p>Code Owners: recurso que permite atribuir revisores espec\u00edficos para determinados arquivos ou pastas em um reposit\u00f3rio do GitHub. Ao definir um arquivo CODEOWNERS na pasta .github, \u00e9 especificado os propriet\u00e1rios respons\u00e1veis por revisar e aprovar as altera\u00e7\u00f5es em determinados caminhos do c\u00f3digo-fonte. Neste projeto exemplo, apenas meu usu\u00e1rio foi definido como revisor Default de todas as mudan\u00e7as.</p> </li> </ul>"},{"location":"#tarefa-5-ambiente-de-producao","title":"Tarefa 5: Ambiente de Produ\u00e7\u00e3o","text":"<p>Preparar a aplica\u00e7\u00e3o para que seja production-ready.</p> <p>Embora o Flask seja um excelente framework para criar aplicativos web em Python de forma r\u00e1pida e simples, ele n\u00e3o \u00e9 considerado \"production ready\" por si s\u00f3. O servidor embutido no Flask \u00e9 adequado apenas para fins de desenvolvimento e testes. Ele n\u00e3o \u00e9 projetado para lidar com cargas de tr\u00e1fego significativas ou oferecer recursos de alta disponibilidade.</p> <p>Com isso, foi escolhido o Guonicorn (Green Unicorn) como ferramenta para tal: um servidor HTTP WSGI (Web Server Gateway Interface) que permite que a aplica\u00e7\u00e3o atenda a mais solicita\u00e7\u00f5es ao mesmo tempo.</p>"},{"location":"#tarefa-6-containerizacao","title":"Tarefa 6: Containeriza\u00e7\u00e3o","text":"<p>Criar arquivos e scripts para que a aplica\u00e7\u00e3o possa ser executada em um container.</p> <p>Foi criado um Dockerfile que copia somente os arquivos necess\u00e1rios para que o container instale as depend\u00eancias do projeto (<code>poetry.lock</code> e <code>pyproject.toml</code>), e rode a aplica\u00e7\u00e3o (conte\u00fado do diret\u00f3rio <code>src/</code>). Isso \u00e9 feito com o aux\u00edlio de um arquivo <code>.dockerignore</code>.</p> <p>Como <code>ENTRYPOINT</code>, o container executa o script <code>scope.sh</code> que roda a aplica\u00e7\u00e3o com o servidor do pr\u00f3prio flask caso exista uma vari\u00e1vel de ambiente <code>LOCAL=True</code> . Caso contr\u00e1rio, o Guonicorn \u00e9 usado.</p>"},{"location":"#tarefa-7-desenvolvimento-local","title":"Tarefa 7: Desenvolvimento Local","text":"<p>Elaborar um modelo de desenvolvimento que permita a execu\u00e7\u00e3o da aplica\u00e7\u00e3o em um ambiente de desenvolvimento local.</p> <p>O modo Debug do Flask, al\u00e9m de fornecer informa\u00e7\u00f5es detalhadas sobre erros e exce\u00e7\u00f5es que ocorrem durante a execu\u00e7\u00e3o, tamb\u00e9m ativar\u00e1 o recurso de \"auto-reload\", que far\u00e1 com que a aplica\u00e7\u00e3o seja recarregada automaticamente sempre que ocorrer uma altera\u00e7\u00e3o no c\u00f3digo.</p> <p>Com um arquivo <code>docker-compose.yml</code>, definimos a cria\u00e7\u00e3o de um container na nossa m\u00e1quina local que ter\u00e1 a vari\u00e1vel de ambiente <code>LOCAL=True</code>, que ativa o modo Debug do Flask e roda a aplica\u00e7\u00e3o sem o Guonicorn.</p> <p>Al\u00e9m disso, \u00e9 usado um Volume mapeando o reposit\u00f3rio local ao diret\u00f3rio da aplica\u00e7\u00e3o no container. Com isso, toda modifica\u00e7\u00e3o do c\u00f3digo fonte tamb\u00e9m \u00e9 alterado dentro do container, e com a fun\u00e7\u00e3o DEBUG, podemos ver as modifica\u00e7\u00f5es sem precisar rebuildar a imagem.</p> <p>Para subir o container localmente, basta usar a task definida no Taskipy <code>task up</code> (subir o container) <code>task down</code> (parar)</p> <pre><code>[tool.taskipy.tasks]\nup = \"docker compose up -d --build --force-recreate\"\ndown = \"docker compose down --rmi local\"\n</code></pre>"},{"location":"#tarefa-8-cicd","title":"Tarefa 8: CI/CD","text":"<p>Construir pipelines de CI/CD para a aplica\u00e7\u00e3o utilizando GitHub Actions. Esse item possui forte rela\u00e7\u00e3o com o fluxo de desenvolvimento, pois deve compreender o deployment em dois ambientes diferentes: homologa\u00e7\u00e3o e produ\u00e7\u00e3o. O deployment da aplica\u00e7\u00e3o deve ser realizado em um servi\u00e7o serverless da Google Cloud Platform.</p> <p>GitHub Actions \u00e9 um servi\u00e7o de automa\u00e7\u00e3o oferecido pelo GitHub para facilitar a cria\u00e7\u00e3o de fluxos de trabalho automatizados. Por meio de arquivos yaml na pasta <code>.github/workflow</code> do reposit\u00f3rio, pode-se definir e configurar tarefas personalizadas que s\u00e3o acionadas por eventos, como push de c\u00f3digo, abertura de pull requests ou outros eventos do reposit\u00f3rio.</p> <ul> <li> <p>docs.yml: com todo \"push\" na <code>main</code> (apenas por meio de um Pull Request aceito) o site de documenta\u00e7\u00e3o gerado pelo MKDocs \u00e9 implantada na plataforma GitHub Actions.</p> </li> <li> <p>lint.yml: com todo Pull Request, a task de \"lint code\" com as ferramentas Semgrep para seguir boas pr\u00e1ticas de seguran\u00e7a e Black, Isort e Flak8 para garantir a boa formata\u00e7\u00e3o do c\u00f3digo Python. Al\u00e9m da ferramente hadolint, por meio de uma action para a devida formata\u00e7\u00e3o do Dockerfile seguindo especifica\u00e7\u00f5es formais.</p> </li> <li> <p>cd.yml: com todo \"push\" na <code>main</code> (apenas por meio de um Pull Request aceito) a imagem Docker da aplica\u00e7\u00e3o \u00e9 buildada para o Container Registry da Google, e depois \u00e9 implantada no Google Run. A autoriza\u00e7\u00e3o \u00e9 feita passando a Json Service Account Access Key por meio de um secret do reposit\u00f3rio. Al\u00e9m disso, h\u00e1 um arquivo <code>cd-dev.yml</code> seguindo o mesmo fluxo, mas para a implanta\u00e7\u00e3o de homologa\u00e7\u00e3o.</p> <p>Obs: A recomenda\u00e7\u00e3o da Cloud Run \u00e9 que os sistemas de CI/CD n\u00e3o definam nem alterem configura\u00e7\u00f5es para permitir \"invoca\u00e7\u00f5es\" n\u00e3o autenticadas. Novas implanta\u00e7\u00f5es s\u00e3o automaticamente configuradas como servi\u00e7os privados, enquanto a implanta\u00e7\u00e3o de uma revis\u00e3o de um servi\u00e7o p\u00fablico (n\u00e3o autenticado) preservar\u00e1 a configura\u00e7\u00e3o de IAM como p\u00fablica (n\u00e3o autenticada). Sendo assim, depois da primeira implanta\u00e7\u00e3o, deve-se realizar o seguinte comando num ambiente com autentica\u00e7\u00e3o para deixar a aplica\u00e7\u00e3o de produ\u00e7\u00e3o p\u00fablica.</p> <pre><code>gcloud run services add-iam-policy-binding [SERVICE_NAME] \\\n    --member=\"allUsers\" \\\n    --role=\"roles/run.invoker\"\n</code></pre> </li> </ul>"},{"location":"app/","title":"Documenta\u00e7\u00e3o da Aplica\u00e7\u00e3o","text":"<p>Foi implementado uma apresenta\u00e7\u00e3o um pouco mais amig\u00e1vel aos olhos com o framework Jinja2. O Jinja \u00e9 um mecanismo de modelo (template engine) em Python que permite incorporar l\u00f3gica e dados din\u00e2micos em modelos est\u00e1ticos.</p> <p>Al\u00e9m disso, foi implementado, ao caminho <code>/word</code> do servi\u00e7o, uma tela de gera\u00e7\u00e3o de Word Art de diferentes tipos. O Word Art \u00e9 uma forma de arte textual que utiliza caracteres ASCII para criar representa\u00e7\u00f5es visuais de palavras ou frases.</p> <p>Project tree</p> <pre><code>    .\n    \u251c\u2500\u2500 Dockerfile\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 docker-compose.yaml\n    \u251c\u2500\u2500 docs\n    \u2502   \u251c\u2500\u2500 app.md\n    \u2502   \u251c\u2500\u2500 assets\n    \u2502   \u2502   \u2514\u2500\u2500 logo.png\n    \u2502   \u2514\u2500\u2500 index.md\n    \u251c\u2500\u2500 mkdocs.yml\n    \u251c\u2500\u2500 poetry.lock\n    \u251c\u2500\u2500 pyproject.toml\n    \u251c\u2500\u2500 scripts\n    \u2502   \u251c\u2500\u2500 run_isort.sh\n    \u2502   \u251c\u2500\u2500 run_semgrep.sh\n    \u2502   \u251c\u2500\u2500 run_test.sh\n    \u2502   \u2514\u2500\u2500 scope.sh\n    \u251c\u2500\u2500 src\n    \u2502   \u251c\u2500\u2500 app.py\n    \u2502   \u2514\u2500\u2500 templates\n    \u2502       \u251c\u2500\u2500 hello.html\n    \u2502       \u2514\u2500\u2500 word_art.html\n    \u2514\u2500\u2500 tests\n        \u2514\u2500\u2500 test_api.py\n</code></pre>"},{"location":"app/#procedimentos-para-contribuir-com-o-desenvolvimento-no-repositorio","title":"Procedimentos para contribuir com o desenvolvimento no reposit\u00f3rio.","text":"<p>Clonar o reposit\u00f3rio</p> <pre><code>git clone https://github.com/storino/emd\n</code></pre> <p>No ambiente de desenvolvimento, instalar poetry para gerenciamento de depend\u00eancias</p> <pre><code>pip3 install poetry\n</code></pre> <p>Instalar as depend\u00eancias para desenvolvimento</p> <pre><code>poetry install\n</code></pre> <p>Instalar os hooks de pr\u00e9-commit</p> <pre><code>pre-commit install\n</code></pre> <p>Para come\u00e7ar o desenvolvimento, entre no ambiente virtual gerado pelo poetry pelo comando</p> <pre><code>poetry shell\n</code></pre> <p>Para sair, basta usar o comando</p> <pre><code>deactivate\n</code></pre> <p>Crie um arquivo <code>.env</code> com as seguintes vari\u00e1veis</p> <pre><code>NAME= # Nome para quem dar \"Ol\u00e1\" :)\nPORT= # Porta da aplica\u00e7\u00e3o\nLOCAL= # Setar ambiente local (Sem Guonicorn e Debug = true)\n</code></pre> <p>Inicialize e pare o container local com os comandos</p> <pre><code>task up\ntask down\n</code></pre> <p>Garantir a boas pr\u00e1ticas de seguran\u00e7a e a formata\u00e7\u00e3o do c\u00f3digo com</p> <pre><code>task lint\n</code></pre> <p>Rode uma inst\u00e2ncia local da documenta\u00e7\u00e3o com</p> <pre><code>task docs\n</code></pre> <p>Rode os testes definidos nos scripts na pasta test/ e veja o quanto os testes atuais cobrem o c\u00f3digo com, respectivamente:</p> <pre><code>task test\ntask cov\n</code></pre> <p>Siga as orienta\u00e7\u00f5es de uso/merge de branches</p> <p>Descri\u00e7\u00e3o da Tarefa 3: Fluxo de Desenvolvimento</p>"}]}